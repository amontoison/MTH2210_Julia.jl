var documenterSearchIndex = {"docs":
[{"location":"fct_index/#Index-des-fonctions-1","page":"Index des fonctions","title":"Index des fonctions","text":"","category":"section"},{"location":"fct_index/#","page":"Index des fonctions","title":"Index des fonctions","text":"Documentation de toute les fonctions du package MTH2210","category":"page"},{"location":"fct_index/#","page":"Index des fonctions","title":"Index des fonctions","text":"Pages = [\"fct_index.md\"]","category":"page"},{"location":"fct_index/#","page":"Index des fonctions","title":"Index des fonctions","text":"Modules = [MTH2210]\nOrder   = [:function, :type]","category":"page"},{"location":"fct_index/#MTH2210.bissec-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.bissec","text":"Résolution d'une équation non-linéaire de forme f(r)=0 avec la méthode de la bissection.\n\nSyntaxe\n\n(approx , err_abs) = bissec(fct , x0 , x1 , nb_it_max , tol_rel)\n\nEntrée\n\n1.  fct         -   Fonction f\n2.  x0          -   (Float) Première approximation initiale\n3.  x1          -   (Float) Deuxième approximation initiale\n4.  nb_it_max   -   (Integer) Nombre maximum d'itérations\n5.  tol_rel     -   (Float) Tolérance sur l'approximation de l'erreur relative\n\nSortie\n\n1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les itérations\n2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues\n\nExemples d'appel\n\nfunction my_fct_nl(x)\n    f = x^2 - 10\n    return f\nend\n(approx , err_abs) = bissec(my_fct_nl , 3 , 3.5 , 200 , 1e-9)\n\n(approx , err_abs) = bissec((x) -> x^2 - 10 , 3 , 3.5 , 200 , 1e-9)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.divided_difference-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Index des fonctions","title":"MTH2210.divided_difference","text":"Calcul de la table des différences divisées\n\nSyntaxe\n\ntable_df = divided_difference(xi , yi )\n\nEntrée\n\n1.  xi         \t-   (Array{Float,1}) Abscisses des points d'interpolation\n2.  yi        \t-   (Array{Float,1}) Ordonnées des points d'interpolation\n\nSortie\n\n1.  table_df \t-   (Array{Float,2}) Table des différences divisées: la 1ère\n                    colonne contient les premières différences divisées, la\n                    2ème colonne (jusqu'à la ligne end-1) contient les deuxièmes\n                    différences divisées,...\n\nExemples d'appel\n\nxi = [2 , 0 , 5 , 3]\nyi = [1 , -1 , 10 , -4]\n\ntable = divided_difference(xi,yi)\ndiff_div1 = table[:,1]\ndiff_div2 = table[1:end-1,2]\ndiff_div3 = table[1:end-2,3]\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.euler-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.euler","text":"Résolution d'EDOs de type fracdYdt(t) = F(tY(t)) avec les conditions initiales Y(t_0) = Y_0 à l'aide de la méthode d'Euler explicite jusqu'au temps t_f avec pas constant h:\n\nY_n+1 = Y_n + h F(t_nY_n)\n\nSyntaxe\n\n(t,Y) = euler(fct , tspan , Y0 , nbpas)\n\nEntrée\n\n1.  fct     -   Fonction décrivant le système de N EDOs\n2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])\n3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales\n4.  nbpas   -   (Integer) Nombre de pas de temps\n\nSortie\n\n1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps\n2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations\n\nExemples d'appel\n\nfunction my_edo(t,z)\n    f = zeros(length(z))\n    f[1] = z[2]\n    f[2] = -z[1]\n    return f\nend\n(t,y)   =   euler(my_edo , [0;10] , [1;0] , 1000)\n\n(t,y)   =   euler((t,y) -> cos(t) , [0;2] , 1 , 1000)\n\n(t,y)   =   euler((t,y) -> [y[2];-y[1]] , [0;10] , [1;0] , 1000)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.eulermod-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.eulermod","text":"Résolution d'EDOs de type fracdYdt(t) = F(tY(t)) avec les conditions initiales Y(t_0) = Y_0 à l'aide de la méthode d'Euler modifié jusqu'au temps t_f avec pas constant h:\n\ntildeY = Y_n + h F(t_nY_n)  Y_n+1 = Y_n + frach2 left(F(t_nY_n) + F(t_n +h tildeY) right)\n\nSyntaxe\n\n(t,Y) = eulermod(fct , tspan , Y0 , nbpas)F(t_n,Y_n) +\n\nEntrée\n\n1.  fct     -   Fonction décrivant le système de N EDOs\n2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])\n3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales\n4.  nbpas   -   (Integer) Nombre de pas de temps\n\nSortie\n\n1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps\n2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations\n\nExemples d'appel\n\nfunction my_edo(t,z)\n    f = zeros(length(z))\n    f[1] = z[2]\n    f[2] = -z[1]\n    return f\nend\n(t,y)   =   eulermod(my_edo , [0;10] , [1;0] , 1000)\n\n(t,y)   =   eulermod((t,y) -> cos(t) , [0;2] , [1] , 1000)\n\n(t,y)   =   eulermod((t,y) -> [y[2];-y[1]] , [0;10] , [1;0] , 1000)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.lagrange-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.lagrange","text":"Interpolation de Lagrange\n\nSyntaxe\n\nLx = lagrange(xi , yi , x)\n\nEntrée\n\n1.  xi          -   (Array{Float,1}) Abscisses des points d'interpolation\n2.  yi          -   (Array{Float,1}) Ordonnées des points d'interpolation\n3.  x           -   (Array{Float,1}) Points où le polynôme d'interpolation est évalué\n\nSortie\n\n1.  Lx          -   (Array{Float,1}) Valeur du polynôme aux points x\n\nExemples d'appel\n\nLx = lagrange([-1,0,1] , [1,0,1] , LinRange(-1,1,200))\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.newton1D-Union{Tuple{T}, Tuple{Function, Function, T, Integer, T}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.newton1D","text":"Résolution d'une équation non-linéaire de forme f(r)=0 avec la méthode de Newton:\n\nx_n+1 = x_n - fracf(x_n)f(x_n)\n\nSyntaxe\n\n(approx , err_abs) = newton1D(fct , dfct , x0 , nb_it_max , tol_rel)\n\nEntrée\n\n1.  fct         -   Fonction f\n2.  dfct        -   Dérivée de la fonction f\n3.  x0          -   (Float) Approximation initiale\n4.  nb_it_max   -   (Integer) Nombre maximum d'itérations\n5.  tol_rel     -   (Float) Tolérance sur l'approximation de l'erreur relative\n\nSortie\n\n1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les itérations\n2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues\n\nExemples d'appel\n\nfunction my_fct_nl(x)\n    f = x^2 - 10\n    return f\nend\nfunction my_dfct_nl(x)\n    df = 2*x\n    return df\nend\n(approx , err_abs) = newton1D(my_fct_nl , my_dfct_nl , 3 , 20 , 1e-9)\n\n(approx , err_abs) = newton1D((x) -> x^2 - 10 , (x) -> 2*x , 3 , 20 , 1e-9)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.newtonND-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Integer, T}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.newtonND","text":"Résolution dun système non-linéaire de forme F(r)=0 avec la méthode de Newton en approximant la matrice jacobienne:\n\nDelta x = tildeJ_F^-1(x_n) F(x_n)  x_n+1 = x_n + Delta x\n\nSyntaxe\n\n(approx , err_abs) = newtonND(fct , x0 , nb_it_max , tol_rel)\n\nEntrée\n\n1.  fct         -   Fonction F\n2.  x0          -   (Array{Float,1}) Vecteur des approximations initiales\n3.  nb_it_max   -   (Integer) Nombre maximum d'itérations\n4.  tol_rel     -   (Float) Tolérance sur l'approximation de l'erreur relative\n\nSortie\n\n1.  approx      -   (Array{Float,2}) Matrice de taille (nb_iter x N) contenant les itérations\n2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues\n\nExemples d'appel\n\nfunction my_sys_nl(x)\n\tF = zeros(eltype(x),length(x))\n\tF[1] = x[1]^2 + x[2]^2 - 1\n\tF[2] = -x[1]^4 + x[2]\n\treturn F\nend\n(approx , err_abs) = newtonND(my_sys_nl , [1,1] , 20 , 1e-9)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.newtonNDder-Union{Tuple{T}, Tuple{Function, Function, AbstractVector{T}, Integer, T}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.newtonNDder","text":"Résolution dun système non-linéaire de forme F(r)=0 avec la méthode de Newton:\n\nDelta x = J_F^-1(x_n) F(x_n)  x_n+1 = x_n + Delta x\n\nSyntaxe\n\n(approx , err_abs) = newtonNDder(fct , jac , x0 , nb_it_max , tol_rel)\n\nEntrée\n\n1.  fct         -   Fonction F\n2.  dfct        -   Matrice jacobienne de la fonction F\n3.  x0          -   (Array{Float,1}) Vecteur des approximations initiales\n4.  nb_it_max   -   (Integer) Nombre maximum d'itérations\n5.  tol_rel     -   (Float) Tolérance sur l'approximation de l'erreur relative\n\nSortie\n\n1.  approx      -   (Array{Float,2}) Matrice de taille (nb_iter x N) contenant les itérations\n2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues\n\nExemples d'appel\n\nfunction my_sys_nl(x)\n\tF = zeros(eltype(x),length(x))\n\tF[1] = x[1]^2 + x[2]^2 - 1\n\tF[2] = -x[1]^2 + x[2]\n\treturn F\nend\nfunction my_sys_nl_jac(x)\n\tjac = zeros(eltype(x),length(x),length(x))\n\tjac[1,1] = 2*x[1]\n\tjac[1,2] = 2*x[2]\n\tjac[2,1] = -2*x[1]\n\tjac[2,2] = 1\n\treturn jac\nend\n(approx , err_abs) = newtonNDder(my_sys_nl , my_sys_nl_jac , [1,1] , 20 , 1e-9)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.ptfixes-Union{Tuple{T}, Tuple{Function, T, Integer, T}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.ptfixes","text":"Résolution d'une équation non-linéaire de forme g(x)=x avec la méthode des points-fixes:\n\nx_n+1 = g(x_n)\n\nSyntaxe\n\n(approx , err_abs) = ptfixes(fct , x0 , nb_it_max , tol_rel)\n\nEntrée\n\n1.  fct         -   Fonction g\n2.  x0          -   (Float) Approximation initiale\n4.  nb_it_max   -   (Integer) Nombre maximum d'itérations\n5.  tol_rel     -   (Float) Tolérance sur l'approximation de l'erreur relative\n\nSortie\n\n1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les itérations\n2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues\n\nExemples d'appel\n\nfunction my_fct_nl(x)\n    g = -x^2/10 + x + 1\n    return g\nend\n(approx , err_abs) = ptfixes(my_fct_nl , 3 , 25 , 1e-9)\n\n(approx , err_abs) = ptfixes( (x) -> -x^2/10 + x + 1 , 3 , 25 , 1e-9)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.ptmilieu-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.ptmilieu","text":"Résolution d'EDOs de type fracdYdt(t) = F(tY(t)) avec les conditions initiales Y(t_0) = Y_0 à l'aide de la méthode du point milieu jusqu'au temps t_f avec pas constant h:\n\nk_1 = h F(t_nY_n)  Y_n+1 = Y_n + hF(t_n + frach2 Y_n + frack_12)\n\nSyntaxe\n\n(t,Y) = ptmilieu(fct , tspan , Y0 , nbpas)\n\nEntrée\n\n1.  fct     -   Fonction décrivant le système de N EDOs\n2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])\n3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales\n4.  nbpas   -   (Integer) Nombre de pas de temps\n\nSortie\n\n1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps\n2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations\n\nExemples d'appel\n\nfunction my_edo(t,z)\n    f = zeros(length(z))\n    f[1] = z[2]\n    f[2] = -z[1]\n    return f\nend\n(t,y)   =   ptmilieu(my_edo , [0;10] , [1;0] , 1000)\n\n(t,y)   =   ptmilieu((t,y) -> cos(t) , [0;2] , 1 , 1000)\n\n(t,y)   =   ptmilieu((t,y) -> [y[2];-y[1]] , [0;10] , [1;0] , 1000)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.rk4-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.rk4","text":"Résolution d'EDOs de type fracdYdt(t) = F(tY(t)) avec les conditions initiales Y(t_0) = Y_0 à l'aide de la méthode de Runge-Kutta d'ordre 4 jusqu'au temps t_f avec pas constant h:\n\nk_1 = h F(t_nY_n)  k_2 = h F(t_n + frach2 Y_n + frack_12)  k_3 = h F(t_n + frach2 Y_n + frack_22)  k_4 = h F(t_n + h Y_n + k_3)  Y_n+1 = Y_n + frac16 left(k_1 + 2k_2 +2k_3 +k_4right)\n\nSyntaxe\n\n(t,Y) = rk4(fct , tspan , Y0 , nbpas)\n\nEntrée\n\n1.  fct     -   Fonction décrivant le système de N EDOs\n2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])\n3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales\n4.  nbpas   -   (Integer) Nombre de pas de temps\n\nSortie\n\n1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps\n2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations\n\nExemples d'appel\n\nfunction my_edo(t,z)\n    f = zeros(length(z))\n    f[1] = z[2]\n    f[2] = -z[1]\n    return f\nend\n(t,y)   =   rk4(my_edo , [0;10] , [1;0] , 1000)\n\n(t,y)   =   rk4((t,y) -> cos(t) , [0;2] , 1 , 1000)\n\n(t,y)   =   rk4((t,y) -> [y[2];-y[1]] , [0;10] , [1;0] , 1000)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.secante-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T<:AbstractFloat","page":"Index des fonctions","title":"MTH2210.secante","text":"Résolution d'une équation non-linéaire de forme f(x)=0 avec la méthode de la sécante:\n\nx_n+1 = x_n - fracf(x_n)left(x_n-x_n-1right)f(x_n)-f(x_n-1)\n\nSyntaxe\n\n(approx , err_abs) = secante(fct , x0 , x1 , nb_it_max , tol_rel)\n\nEntrée\n\n1.  fct         -   Fonction f\n2.  x0          -   (Float) Première approximation initiale\n2.  x1          -   (Float) Deuxième approximation initiale\n4.  nb_it_max   -   (Integer) Nombre maximum d'itérations\n5.  tol_rel     -   (Float) Tolérance sur l'approximation de l'erreur relative\n\nSortie\n\n1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les\titérations\n2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues\n\nExemples d'appel\n\nfunction my_fct_nl(x)\n    f = x^2 - 10\n    return f\nend\n(approx , err_abs) = secante(my_fct_nl , 3 , 3.5 , 20 , 1e-9)\n\n(approx , err_abs) = secante((x) -> x^2 - 10 , 3 , 3.5 , 20 , 1e-9)\n\n\n\n\n\n","category":"method"},{"location":"fct_index/#MTH2210.splinec-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Index des fonctions","title":"MTH2210.splinec","text":"Interpolation par les splines cubiques\n\nSyntaxe\n\nSx = splinec(xi , yi , x , type_f , val_f)\n\nEntrée\n\n1.  xi          -   (Array{Float,1}) Abscisses des points d'interpolation\n2.  yi          -   (Array{Float,1}) Ordonnées des points d'interpolation\n3.  x           -   (Array{Float,1}) Points où la spline cubique est évaluée\n4.  type_f      -   (Array{Integer,1}) Vecteur des types de conditions frontières\n                    imposées en x_0 et x_n. Les choix possibles sont:\n                        [1,1] -> Spline naturelle\n                        [2,2] -> Spline avec courbure prescrite\n                        [3,3] -> Spline avec courbure constane\n                        [4,4] -> Spline avec pente prescrite\n                        [i,j] -> Spline avec condition i imposée en x0 et\n                                 condition j imposée en xn\n\n5.  val_f       -   (Array{Float,1}) Vecteur des valeurs des conditions frontières\n                    imposées en x_0 et x_n. Les choix possibles sont:\n                        - Si type_S[1] = 1 ou 3, alors val_S[1] = NaN\n                        - Si type_S[1] = 2 ou 4, alors val_S[1] = a, où a\n                          représente resp. la courbure ou la pente en x0\n                        - Si type_S[2] = 1 ou 3, alors val_S[2] = NaN\n                        - Si type_S[2] = 2 ou 4, alors val_S[2] = b, où b\n                          représente resp. la courbure ou la pente en xn\n\nSortie\n\n1.  Sx          -   (Array{Float,1}) Valeur de la spline cubique aux points x\n\nExemples d'appel\n\nSx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [1,1] , [NaN,NaN])\nSx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [2,2] , [5,-6])\nSx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [3,3] , [NaN,NaN])\nSx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [4,4] , [-30,-10])\nSx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [3,4] , [NaN,-10])\n\n\n\n\n\n","category":"method"},{"location":"mise_en_place/#Mise-en-place-de-Julia-1","page":"Mise en place","title":"Mise en place de Julia","text":"","category":"section"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"Les étapes permettant d'installer Julia ainsi que les programmes nécessaires afin d'obtenir une interface de type IDE avec l'éditeur Atom sont décrites dans cette section.","category":"page"},{"location":"mise_en_place/#Installation-de-Julia-1","page":"Mise en place","title":"Installation de Julia","text":"","category":"section"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"Le langage de programmation Julia peut être téléchargée sur le site web Download Julia. La version v1 ou une version plus récente doit être téléchargée.","category":"page"},{"location":"mise_en_place/#Installation-d'Atom-et-des-autres-packages-1","page":"Mise en place","title":"Installation d'Atom et des autres packages","text":"","category":"section"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"L'éditeur de texte Atom doit être téléchargé. Il faut ensuite télécharger le package Juno sur Atom. Pour ce faire, une fois Atom ouvert, il faut aller dans Setting via le menu File ou avec la commande Ctrl+,. Une fois dans Setting, sélectionnez l'onglet Install et suivez les étapes suivantes:","category":"page"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"Installez le package uber-juno\nOuvrez les Settings du package uber-juno et assurez vous que l'option Disable - Don't run installation when Atom boots est déselectionné.\nRedémarrez l'éditeur Atom. Atom devrait alors installer de nouveaux packages.\nRedémarrez une dernière fois l'éditeur Atom.","category":"page"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"Une nouvelle barre d'outils devrait apparaître sur l'interface d'Atom. Si cette barre n'est pas visible, vous pouvez la faire apparaître/disparaître avec la commande Ctrl+Alt+T. De plus, sous le menu Packages d'Atom, une entrée Julia devrait maintenant être présente. Si vous rencontrez des problèmes, assurez vous que les packages suivants d'Atom sont installés:","category":"page"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"latex-completion\nindent-detective\nink\njulia-client\nlanguage-julia\ntool-bar","category":"page"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"warning: Avertissement\nVous devez vous assurer que les packages d'Atom soit capable de trouver l'éxécutable de Julia. Pour ce faire, vérifiez en cliquant sur le menu Package, puis Julia puis Settings si le champ Julia Path est vide. Si c'est le cas, indiquez l'emplacement de l'éxécutable de Julia, habituellement il s'agit de C:\\Users\\VotreNom\\AppData\\Local\\Julia-version\\bin\\julia.exe sous Windows.","category":"page"},{"location":"mise_en_place/#Installation-du-package-MTH2210-1","page":"Mise en place","title":"Installation du package MTH2210","text":"","category":"section"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"Afin d'installer le package MTH2210, vous devez éxécuter la commande suivante dans la console de Julia.","category":"page"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"julia> ]\npkg> add https://github.com/amontoison/MTH2210.jl.git\npkg> test MTH2210\njulia> using MTH2210","category":"page"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"Les packages suivants doivent aussi être installés:","category":"page"},{"location":"mise_en_place/#","page":"Mise en place","title":"Mise en place","text":"Affichage de graphique : Plots,\nGénération d'un rapport : Weave.","category":"page"},{"location":"generate_pdf/#Génération-d'un-fichier-pdf-1","page":"Génération d'un rapport","title":"Génération d'un fichier pdf","text":"","category":"section"},{"location":"generate_pdf/#","page":"Génération d'un rapport","title":"Génération d'un rapport","text":"Le package Weave permet de générer un rapport sous format pdf d'un script Julia.","category":"page"},{"location":"generate_pdf/#","page":"Génération d'un rapport","title":"Génération d'un rapport","text":"Le fichier gabarit_rapport.jl est un gabarit de rapport. Après avoir édité votre script, vous pouvez publier votre script en format pdf (avec pdflatex) avec la commande:","category":"page"},{"location":"generate_pdf/#","page":"Génération d'un rapport","title":"Génération d'un rapport","text":"using Weave\nweave(\"gabarit_rapport.jl\", doctype = \"md2pdf\")","category":"page"},{"location":"generate_pdf/#","page":"Génération d'un rapport","title":"Génération d'un rapport","text":"ou en format HTML avec la commande:","category":"page"},{"location":"generate_pdf/#","page":"Génération d'un rapport","title":"Génération d'un rapport","text":"using Weave\nweave(\"gabarit_rapport.jl\", doctype = \"md2html\")","category":"page"},{"location":"generate_pdf/#","page":"Génération d'un rapport","title":"Génération d'un rapport","text":"Il est important d'imprimer ensuite le fichier HTML en format pdf pour la remise sur Moodle.","category":"page"},{"location":"generate_pdf/#","page":"Génération d'un rapport","title":"Génération d'un rapport","text":"warning: Avertissement\nLes lignes de code précédentes ne doivent pas se retrouver dans votre script. Vous devez les éxécuter dans la console de Julia en vous assurant d'être dans le dossier contenant le fichier gabarit_rapport.jl.","category":"page"},{"location":"edo/#Résolution-d'équations-différentielles-ordinaires-1","page":"Équations différentielles ordinaires","title":"Résolution d'équations différentielles ordinaires","text":"","category":"section"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"Cette section est dédiée à la résolution numérique d'équations ordinaires de forme:","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"fracdYdt(t) = F(tY(t)) quad textavec quad Y(t_0) = Y_0.","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"Les algorithmes disponibles sont:","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"Euler explicite: euler,\nEuler modifié: eulermod,\nPoint milieu: ptmilieu,\nRunge-Kutta d'ordre 4: rk4.","category":"page"},{"location":"edo/#Exemple-de-résolution-d'un-système-d'équations-différentielles-ordinaires-1","page":"Équations différentielles ordinaires","title":"Exemple de résolution d'un système d'équations différentielles ordinaires","text":"","category":"section"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"Soit l'équation différentielle ordinaire d'ordre 2 décrivant un système masse-ressort de masse m=2textkg et de constante de rappel k=3textNm:","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"fracd^2 ydt^2(t) = -frackm y(t) quad textavec quad y(1) = 5 text et  fracd ydt(1) =0.","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"On s'intéresse à la solution entre t_0=1texts et t_f = 4texts. On doit tout d'abord effectuer un changement de variables:","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"z_1(t) = y(t) z_2(t) = fracd ydt(t)","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"afin de transformer l'EDO d'ordre 2 en ce système d'EDOs d'ordre 1:","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"fracd z_1dt(t) = z_2(t) fracd z_2dt(t) = -frackmz_1(t)","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"On peut appliquer la méthode d'Euler explicite afin de résoudre ce système d'EDOs. Il faut donc créer la fonction FmathbbR times mathbbR^2 to mathbbR^2:","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"function my_edo(t,z)\n    m = 2.\n    k = 3.\n    f = zeros(length(z))\n    f[1] = z[2]\n    f[2] = -k/m*z[1]\n    return f\nend\nnothing # hide","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"Il faut ensuite appeler la fonction euler:","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"using MTH2210\nusing Plots\n\nt0 = 1.\ntf = 4.\ntspan = [t0,tf]\nz0 = [5.,0.]\nnbpas = 1000\n(temps, z) = euler(my_edo, tspan , z0 , nbpas)\nnothing # hide","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"Les résultats peuvent ensuite être affichés dans un graphique.","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"plot(temps,z[:,1],label=\"y(t)\")\nplot!(temps,z[:,2],label=\"y'(t)\",xlabel=\"temps [s]\",title=\"Approximation avec Euler exp.\")\nplot!([],[],label=\"\",size=(400,300)); savefig(\"edo-plot.png\"); nothing # hide","category":"page"},{"location":"edo/#","page":"Équations différentielles ordinaires","title":"Équations différentielles ordinaires","text":"(Image: Solutions numériques du systèmes d'EDOs)","category":"page"},{"location":"prob_non_lin/#Résolution-de-problèmes-non-linéaires-1","page":"Problèmes non-linéaires","title":"Résolution de problèmes non-linéaires","text":"","category":"section"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"Cette section est dédiée à la résolution de problèmes non-linéaires. Deux types  de problèmes non-linéaires sont étudiés, le premier est le problème de  recherche de racines r in mathbbR^n de  FmathbbR^n to mathbbR^n:","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"F(r) = 0.","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"Les algorithmes disponibles pour trouver les racines d'une fonction F sont:","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"Bissection pour n=1 : bissec,\nSécante pour n=1 : secante,\nNewton avec dérivée pour n=1 : newton1D,\nNewton avec dérivée pour ngeq 1 : newtonNDder,\nNewton sans dérivée pour ngeq 1 : newtonND.","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"Le deuxième type de problème à résoudre est le problème de recherche d'un point fixe z in mathbbR^n d'une fonction GmathbbR^n to mathbbR^n:","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"G(z) = z.","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"L'algorithme disponible pour trouver les points-fixes d'une fonction g est:","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"Point-fixe pour n=1 : ptfixes","category":"page"},{"location":"prob_non_lin/#Exemple-de-résolution-d'une-équation-non-linéaire-1","page":"Problèmes non-linéaires","title":"Exemple de résolution d'une équation non-linéaire","text":"","category":"section"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"On cherche à calculer une approximation de sqrt10 en calculant la racine positive de f(x) = x^2 - 10. On définit tout d'abord la fonction f:","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"function my_fct_nl(x)\n    f = x^2 - 10\n    return f\nend\nfunction my_dfct_nl(x)\n    df = 2*x\n    return df\nend\nnothing # hide","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"On appelle ensuite les fonctions bissec, secante et newton1D afin de résoudre ce problème. On choisit x_0=25 et x_1=4 de sorte que f(x_0)f(x_1)0 et une tolérance sur l'erreur relative de tol=10^-9.","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"using MTH2210\nusing Plots\nusing Printf\n\nx0 = 2.5\nx1 = 4.\ntol = 1e-9\n(approx_bis , err_bis) = bissec(my_fct_nl , x0 , x1 , 100 , tol)\n(approx_sec , err_sec) = secante(my_fct_nl , x0 , x1 , 50 , tol)\n(approx_new , err_new) = newton1D(my_fct_nl , my_dfct_nl , x0 , 20 , tol)\nnothing # hide","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"La méthode des points-fixes peut aussi être employée pour approximer sqrt10. On considère la fonction g(x) = -fracx^210 + x+ 1 dont un point-fixe est sqrt10","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"function g(x)\n    g = -x^2/10 + x + 1\n    return g\nend\n(approx_fixe , err_fixe) = ptfixes(g , x0 , 50 , 1e-9)\nnothing # hide","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"On peut ensuite afficher l'évolution des erreurs selon l'itération.","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"warning: Avertissement\nIl est important de sélectionner les éléments non-nuls des vecteurs err_bis, err_sec, err_new et err_fixe afin de pouvoir les afficher avec un axe logarithmique (yscale=:log10). Pour ce faire, on peut utiliser l'indexation logique err_bis[err_bis.>0].","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"plot(1:length(err_bis[err_bis.>0]),err_bis[err_bis.>0],label=\"Bissection\")\nplot!(1:length(err_sec[err_sec.>0]),err_sec[err_sec.>0],label=\"Sécante\")\nplot!(1:length(err_new[err_new.>0]),err_new[err_new.>0],label=\"Newton\")\nplot!(1:length(err_fixe[err_fixe.>0]),err_fixe[err_fixe.>0],label=\"Pt-fixe\",\n      xlabel=\"nb itérations\",ylabel=\"Erreur absolue\",yscale=:log10)\nplot!([],[],label=\"\",size=(400,300)); savefig(\"nl-plot.png\"); nothing # hide","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"(Image: Erreurs pour les algorithmes de résolution d'équation non-linéaire)","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"Les tableaux des ratios des erreurs peuvent aussi être produits pour les méthodes des points-fixes, de la sécante et de Newton:","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"ratio_fixe_1 = err_fixe[2:end] ./ err_fixe[1:end-1]\nratio_fixe_a = err_fixe[2:end] ./ err_fixe[1:end-1] .^ ((1+sqrt(5))/2)\nratio_fixe_2 = err_fixe[2:end] ./ err_fixe[1:end-1] .^ 2\n\nratio_sec_1 = err_sec[2:end] ./ err_sec[1:end-1]\nratio_sec_a = err_sec[2:end] ./ err_sec[1:end-1] .^ ((1+sqrt(5))/2)\nratio_sec_2 = err_sec[2:end] ./ err_sec[1:end-1] .^ 2\n\nratio_new_1 = err_new[2:end] ./ err_new[1:end-1]\nratio_new_a = err_new[2:end] ./ err_new[1:end-1] .^ ((1+sqrt(5))/2)\nratio_new_2 = err_new[2:end] ./ err_new[1:end-1] .^ 2\n\n@printf(\"Ratio des erreurs pour points-fixes\\n\")\n@printf(\"e_{n+1}/e_{n}           e_{n+1}/e_{n}^a         e_{n+1}/e_{n}^2\\n\")\nfor t=1:length(ratio_fixe_1)\n    @printf(\"%16.15e   %16.15e   %16.15e\\n\", ratio_fixe_1[t] , ratio_fixe_a[t] , ratio_fixe_2[t])\nend\n@printf(\"\\n\\nRatio des erreurs pour la sécante\\n\")\n@printf(\"e_{n+1}/e_{n}           e_{n+1}/e_{n}^a         e_{n+1}/e_{n}^2\\n\")\nfor t=1:length(ratio_sec_1)\n    @printf(\"%16.15e   %16.15e   %16.15e\\n\", ratio_sec_1[t] , ratio_sec_a[t] , ratio_sec_2[t])\nend\n@printf(\"\\n\\nRatio des erreurs pour Newton\\n\")\n@printf(\"e_{n+1}/e_{n}           e_{n+1}/e_{n}^a         e_{n+1}/e_{n}^2\\n\")\nfor t=1:length(ratio_new_1)\n    @printf(\"%16.15e   %16.15e   %16.15e\\n\" , ratio_new_1[t] , ratio_new_a[t] , ratio_new_2[t])\nend","category":"page"},{"location":"prob_non_lin/#","page":"Problèmes non-linéaires","title":"Problèmes non-linéaires","text":"On constate, tel qu'attendu, que la méthode de la sécante converge au nombre d'or frac1+ sqrt52, que la méthode de Newton converge à l'ordre 2 et que la méthode des points-fixes converge à l'ordre 1 et à un taux de convergence de -frac2sqrt1010+1.","category":"page"},{"location":"interpolation/#Résolution-de-problèmes-d'interpolation-1","page":"Interpolation","title":"Résolution de problèmes d'interpolation","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Cette section est dédiée à la résolution de problèmes d'interpolation. Le premier type d'interpolation consiste à résoudre le problème suivant: Connaissant les n+1 points d'interpolation (x_0y_0)(x_1y_1)ldots (x_ny_n), on cherche le polynôme p de degré n tel que p(x_0)=y_0 p(x_1)=y_1ldotsp(x_n)=y_n. L'algorithme disponible pour résoudre ce problème est la méthode de Lagrange: lagrange. L'algorithme employée est une version autre que celle du cours et est basé sur Barycentric Lagrange Interpolation (Berrut J. et Trefethen L.N.).","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Une autre méthode d'interpolation est la spline cubique et l'algorithme disponible est la méthode des splines cubiques: splinec","category":"page"},{"location":"interpolation/#Exemple-d'interpolation-avec-la-méthode-de-Lagrange-1","page":"Interpolation","title":"Exemple d'interpolation avec la méthode de Lagrange","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Soit les points d'interpolation (-12)  (0-4)  (2510)  (35). On veut afficher le polynôme de degré 3 sur l'intervalle -13. On utilise la fonction lagrange ainsi:","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"using MTH2210\nusing Plots\n\nxi = [-1.,0.,2.5,3.]\nyi = [2.,-4.,10.,5.]\nxfin = LinRange(minimum(xi),maximum(xi),250)\nLx = lagrange(xi , yi , xfin)\n\nplot(xi,yi,linetype=\"scatter\",label=\"Pt inter\")\nplot!(xfin,Lx,label=\"P3(x)\",xlabel=\"x\",legend=:bottomright)\nplot!([],[],label=\"\",size=(400,300)); savefig(\"lagrange-plot.png\"); nothing # hide","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"(Image: Interpolation de Lagrange)","category":"page"},{"location":"interpolation/#Exemple-d'interpolation-avec-la-méthode-des-splines-cubiques-1","page":"Interpolation","title":"Exemple d'interpolation avec la méthode des splines cubiques","text":"","category":"section"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"On peut aussi employer une spline cubique afin d'interpoler les points précédents. On impose que S(x_0) = 10 et S(x_3) = 50.","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"Sx = splinec(xi , yi , xfin , [4,2] , [10.,50.])\n\nplot(xi,yi,linetype=\"scatter\",label=\"Pt inter\")\nplot!(xfin,Sx,label=\"Spline cubique\",xlabel=\"x\",legend=:bottomright)\nplot!([],[],label=\"\",size=(400,300)); savefig(\"splinec-plot.png\"); nothing # hide","category":"page"},{"location":"interpolation/#","page":"Interpolation","title":"Interpolation","text":"(Image: Interpolation avec spline cubique)","category":"page"},{"location":"#MTH2210.jl-Fonctions-pour-le-cours-MTH2210-1","page":"Accueil","title":"MTH2210.jl - Fonctions pour le cours MTH2210","text":"","category":"section"},{"location":"#","page":"Accueil","title":"Accueil","text":"Le package MTH2210.jl contient toutes les fonctions Julia présentées dans le cadre du cours MTH2210 de l'École Polytechnique de Montréal.","category":"page"},{"location":"#Auteurs-:-Antonin-Paquette-et-Alexis-Montoison-1","page":"Accueil","title":"Auteurs : Antonin Paquette et Alexis Montoison","text":"","category":"section"},{"location":"julia_vs_matlab/#Julia-vs-MatLab-1","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Cette page se veut une description sommaire des différences entre les languages de programmation MatLab et Julia. Cette page ne se veut pas être une revue exhaustive ni complète des différences entre ces deux langages, mais un sommaire permettant à un utilisateur habitué à MatLab de pouvoir être minimalement fonctionnel sur Julia. Un complément d'informations peut être trouvé sur cette page web de la documentation de Julia Noteworthy Differences from other Languages et sur cette cheatsheet.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Une des différences majeures entre Julia et MatLab est que MatLab représente par défaut ces données dans dans des matrices contenant des Float64, tandis que Julia type fortement ces variables. Notamment, Julia distingue les integer et les float à l'aide d'un point . suivant immédiatemment le nombre. Par exemple, la commande suivante crée un integer (Int64 sur la majorité des machines):","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"a = 3\ntypeof(a)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Alors que la syntaxe suivante crée un float (Float64 sur la majorité des machines):","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"b = 3.\ntypeof(b)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Aussi, Julia fait la différence entre une variable de type Float64 et un vecteur contenant des Float64.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"c = -1.\nd = [-1.]","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Ceci engendre donc des différences dans l'utilisation de certaines fonctions. Par exemple, si l'on veut calculer les valeurs absolues d'un Float64 et les valeurs absolues des éléments d'un vecteur (ou d'une matrice), on obtient les résultats suivants:","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"abs(c)\nabs(d)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Il sera indiqué à la section Opérations sur des vecteurs et des matrices comment effectuer cette opération simple à effectuer sur MatLab.","category":"page"},{"location":"julia_vs_matlab/#Création-de-vecteurs-et-de-matrices-1","page":"Julia vs MatLab","title":"Création de vecteurs et de matrices","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"La première différence notable avec MatLab est le fait que Julia distingue les vecteurs des matrices. Les vecteurs sont des array de dimension 1, alors que les matrices sont des array dimension 2. En Julia, la convention adoptée est de type column-major order, les vecteurs sont de type colonne. Afin de créer un vecteur sur Julia, on emploie les crochets [] et on sépare les éléments par des virgules ou des point-virgules ;.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"x = [1,2,3]\ny = [1;2;3]","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Les matrices sont quant à elles créées encore à l'aide de crochets [], mais les éléments sur une même ligne doivent être séparés pas des espaces et un saut de ligne s'indique par le point-virgule ;.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"A = [1 2 3; 4 5 6]","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"note: Note\nLa commande suivante créera un array de dimension 2 possédant une ligne et 3 colonnes au lieu d'un vecteurz = [1 2 3]","category":"page"},{"location":"julia_vs_matlab/#creation_vec_mat-1","page":"Julia vs MatLab","title":"Opérations sur des vecteurs et des matrices","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Julia récupère quelques éléments syntaxiques de MatLab concernant les opérations sur arrays, mais diffère sur quelques points. Comme dans MatLab, les opérations élément par élément s'effectuent à l'aide du point .. Ainsi, les opérations suivantes sont les mêmes que sur MatLab.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"v=[1,2]\nB=[1 2 ; 3 4]\nC=[5 -6 ; -7 8]\n\nB*C\nB.*C\n\nB^2\nB.^2\n\nB*v\nB.*v","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"La multiplication d'un vecteur ou une matrice par un nombre est définie comme sur MatLab.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"2.5*v\n2.5*B\nC/3","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Les opérations différentes concernent notamment les opérations d'addition/soustraction et les comparaison logique. L'addition/soustraction d'un nombre et d'un vecteur/matrice n'est pas définie en Julia, il faut donc utiliser le ..","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"2 + B\n2 .+ B\nB - C\nB .- C","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Pour les opérateurs logiques, il faut aussi employer le . afin de comparer éléments par éléments.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"2 == B\n2 .== B\n2 .<= B\n\nB<C\nB.<C","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"warning: Important\nÉtant donné que le point . permet à la fois de définir un float et d'effectuer les opérations éléments par éléments, il faut mettre des espaces entre les points afin de pouvoir distinguer la signification de chaque point .. La commande suivante:5.+[1,2]produira le message d'erreur suivant:ERROR: syntax: invalid syntax \"5.*\"; add space(s) to clarifyIl faut alors utiliser la syntaxe suivante:5. .+ [1,2]","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Les fonctions mathématiques standards définies sur mathbbR n'acceptent pas des vecteurs sous Julia. Il faut donc employer le point . immédiatemment après le nom de la fonction afin d'appliquer la fonction élément par élément.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"cos(v)\ncos.(v)\nmod(B,3)\nmod.(B,3)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Cette syntaxe s'applique à toute les fonctions écrit sur Julia, que cela soit les fonctions des librairies standards de Julia ou des fonctions créées par l'utilisateur.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"warning: Avertissement\nCertaines fonctions mathématiques sont définies sur des matrices carrés, tels les fonctions trigonométriques, l'exponentiation et la puissance. Il faut donc faire attention à savoir si l'on veut effectuer ces opérations sur la matrice ou sur les éléments de la matrice. L'exemple suivant illustre ces différences:M=[0 1 ; 2 -1]\nexp(M)produit le résultat suivant:2×2 Array{Float64,2}:\n1.8573   0.860982\n1.72196  0.996317Alors que la commande suivante:exp.(M)effectue l'exponentiation élément par élément:2×2 Array{Float64,2}:\n1.0      2.71828\n7.38906  0.367879","category":"page"},{"location":"julia_vs_matlab/#Indexation,-*slices*-et-concaténation-de-vecteurs-et-de-matrices-1","page":"Julia vs MatLab","title":"Indexation, slices et concaténation de vecteurs et de matrices","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"On accède aux éléments d'un vecteur ou d'une matrice à l'aide des crochets [] comparativement à MatLab ou l'on accède aux éléments avec les parenthèse (). Le reste de la syntaxe est identique à celle de MatLab, la numérotation commence à 1 et le dernier élément peut être extrait avec end. Les dimensions sont aussi séparées par des virgules ,.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"w=[-1,2,3]\nE=[1 2 3 ; 4 5 6 ; 7 8 9]\n\nw[2:end]\nE[[1,3],1:2]\nE[[1,3],[1:2]]","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"La dernière commande engendre une erreur, ce qui permet d'illustrer une subtile différence entre Julia et MatLab. MatLab interprète la commande [1:2] en créant un vecteur contenant [1,2], alors que Julia crée un array d'array, ce qui génère l'erreur.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"La concaténation s'effectue selon la même logique que la création d'une matrice, on emploie l'espace pour concaténer horizontalement et le point-virgule ; pour concaténer verticalement  ","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"[E E]\n[E;E]\n[w E]\n[E ; w']","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"La syntaxe pour modifier un ou des éléments d'un vecteur ou d'une matrice est la même que sur MatLab. Toutefois, puisque Julia est fortement typé, les commandes suivantes produisent des erreurs étant donné que les types ne concordent pas.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"E[1,1] = [-1]\nE[2:3,[1,3]] = -4","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"En comparaison, les commandes suivantes ne produisent pas d'erreurs:","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"E[1,1] = -1\nE[1:1,1] = [-1]\nE[2:3,[1,3]] .= -4","category":"page"},{"location":"julia_vs_matlab/#Passer-par-valeur-ou-par-référence?-1","page":"Julia vs MatLab","title":"Passer par valeur ou par référence?","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Une différence majeure entre MatLab et Julia est le fait que MatLab effectue des copies de ses variables, alors que Julia effectue parfois le référencement.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"A = [1 2 ; 3 4]\nB = A;\nB[1,1] = -9;\nA","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"La deuxième commande ne crée pas une copie de A, mais indique plutôt que B pointe vers le même espace mémoire que A. Ainsi, toute modification à A ou à B sera effectuée sur les deux variables.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Toutefois, dès qu'une opération de slices consistant à extraire un sous-vecteur d'un array est effectuée, une copie est créée.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"A = [1 2 ; 3 4]\nC = A[1,:]\nA[1,1] = -5;\nC","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Si l'on veut que la variable C pointe vers l'espace mémoire de A, il faut plutôt employer la fonction view.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"A = [1 2 ; 3 4]\nD = view(A,1,1:2)\nA[1,1] = -3;\nD","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Lorsqu'un array est passé en argument dans une fonction, l'argument est passé par référence. Ainsi, toute modification de cet array dans la fonction se réflètera à l'extérieur de cette fonction. Ceci constitue une très grosse différence par rapport à MatLab, où toutes les variables modifiées au sein d'une fonction sont passées par valeur et non par référence.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"A = [1 2 ; 3 4]\nfunction demo!(M)\n    M[1,1] = -11\n    T = 1 .+ M\n    return T\nend\n\nS = demo!(A)\nA","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"note: Note\nPar convention, les fonctions modifiant les variables passées en arguments sont notées avec un point d'exclamation !.","category":"page"},{"location":"julia_vs_matlab/#Création-d'une-fonction-1","page":"Julia vs MatLab","title":"Création d'une fonction","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Sur MatLab, la création de fonctions ne peut s'effectuer qu'à la fin d'un script ou en écrivant un fichier .m contenant la définition d'une fonction. Julia est plus versatile, car des fonctions peuvent être définies n'importe où dans un script et même à l'intérieur d'autres fonctions. L'exemple suivant permet de définir la fonction y(x) = x cos(x) -e^x.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"function exemple1(x)\n    y = x * cos(x) - exp(x)\n    return y\nend\nx = LinRange(0,1,250)\nz1 = exemple1.(x)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"warning: Important\nla fonction est appellée avec un point étant donné que le veut évaluer la fonction sur chaque élément du vecteur x.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Cette dernière fonction peut être définie de manière plus compacte ainsi:","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"exemple2(x) = x * cos(x) - exp(x)\nz2 = exemple2.(x)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Voici un exemple d'une fonction permettant de retourner les éléments d'un vecteur plus petit ou égal à une valeur p et les valeurs strictement plus grande que p.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"function exemple3(x,p)\n    vector_petit = x[x .<= p]\n    vector_grand = x[x .> p]\n    return vector_petit , vector_grand\nend\n\ntest = [1,5,-9,3,-5,2,8,12,7]\n(vec1,vec2) = exemple3(test,2);\nvec1\nvec2","category":"page"},{"location":"julia_vs_matlab/#Scope/portée-des-variables-1","page":"Julia vs MatLab","title":"Scope/portée des variables","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Une autre différence majeure entre MatLab et Julia réside dans la portée/scope des variables. Sur MatLab, les variables globales doivent être déclarées à la fois dans le script et dans les fonctions employant ces variables. Ces variables peuvent être modifiées et ces modifications seront accessibles partout. Sur Julia, les variables globales sont celles définies dans un script, le REPL ou dans un module. Les variables globales dans Julia peuvent seulement être modifiées dans le scope global (changer des éléments d'un array ne consiste pas à changer la variable). Les fonctions et les boucles for/while introduisent un scope local qui hérite de toutes les variables du scope parent (qu'elles soient globales ou locales). Si une variable introduite dans le scope local possède le même nom qu'une variable globale, une nouvelle variable possédant le même nom sera créée, mais sa portée sera restreint qu'au scope local (c'est pourquoi, dans l'exemple suivant,  la variable c n'est pas définie en dehors de la boucle for).","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"b = 1\nfor t=1:5\n    b = -2\n    c = t + b\n    println(c)\nend\nb\nc\n\nfunction test1()\n    b = 3\n    println(b)\nend\ntest1()\nb","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Le script suivant produit une erreur étant donné que la variable b dans le scope de la boucle for ne correspond pas au b du scope global. Une nouvelle variable b est alors créée dans le scope de la boucle for, ce qui engendre une erreur puisque cette variable n'est pas initialisée.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"b = 1\n\nfor t=1:10\n    b = b + 1\nend","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Les variables locales sont aussi passées aux scopes enfants. Ces variables peuvent toutefois être modifiées à l'intérieur de ces scopes enfants, contrairement aux variables globales.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"b = 1\nfunction test2()\n    x = 2\n    function test_in()\n        x = 3\n        return x + b\n    end\n    return test_in() + x\nend\ntest2()","category":"page"},{"location":"julia_vs_matlab/#Affichage-de-textes-et-de-tableaux-sur-la-console-1","page":"Julia vs MatLab","title":"Affichage de textes et de tableaux sur la console","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Afin d'afficher une ligne de texte sur MatLab, on emploie la commande fprintf, alors que sur Julia, il faut utiliser la macro @printf. Cette macro se retrouve dans le package Printf qui doit être importé. Le reste de la syntaxe reste néanmoins similaire à celle de MatLab.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"using Printf\n\nn = 1:6; v1 = 2 .^ n; v2 = 2 .^ (1 ./ n);\n\n@printf(\"n   2^n   2^(1/n)\\n\")\nfor t=1:length(n)\n    @printf(\"%2d   %2d   %16.15e\\n\",n[t],v1[t],v2[t])\nend","category":"page"},{"location":"julia_vs_matlab/#Affichage-de-graphiques-1","page":"Julia vs MatLab","title":"Affichage de graphiques","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Afin d'afficher des graphiques avec Julia, il faut utiliser le package Plots, en employant la commande using Plots. Les attributs spécifiant les propriétés des courbes et des graphiques doivent être décrites lors de la création de ces mêmes courbes, comparativement à Matlab. L'exemple suivant permet de créer une courbe rouge représentant la fonction sin et une courbe bleue représentant la fonction cos.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"using Plots\n\nx = LinRange(-2*pi,2*pi,250); y1 = sin.(x); y2 = cos.(x);\n\nplot(x,y1,label=\"sin(x)\",color=\"red\")\nplot!(x,y2,label=\"cos(x)\",color=\"blue\",xlabel=\"x\",ylabel=\"y\",title=\"Un premier graphique\")\n\nplot!([],[],label=\"\",size=(400,300)); savefig(\"tutorial-plot1.png\"); nothing # hide","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"(Image: Graphique #1)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Le titre de chaque courbe est spécifié avec l'attribut label et la couleur avec l'attribut color. Pour afficher plusieurs courbes sur le même graphique, il faut utiliser la commande terminée par un ! (ici la commande est plot!). Finalement, le titre des axes et du graphiques sont spécifiés.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Afin d'afficher des points sur un graphique, on change l'attribut linetype pour scatter.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"y3 = 2 .* rand(length(x)) .- 1;\n\nplot!(x,y3,label=\"random\",color=\"green\",linetype=\"scatter\")\n\nplot!([],[],label=\"\",size=(400,300)); savefig(\"tutorial-plot2.png\"); nothing # hide","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"(Image: Graphique #1)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Afin de créer un graphique avec des axes en base logarithmique, il faut employer l'attribut xscale=:log10 pour l'axe x ou yscale=:log10 pour l'axe y. Le package Plots génèrera toutefois des erreurs si des éléments sont nuls ou négatifs lorsque l'on emploie des axes logarithmiques. Il faut donc seulement selectionner les éléments strictement plus grand que 0.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"data_x = 1:5;\ndata_y = [1e-3,1e-7,-1e-4,1e-5,0];\n\nplot(data_x[data_y.>0],data_y[data_y.>0],yscale=:log10,title=\"Graphique avec axe y de type log\")\n\nplot!([],[],label=\"\",size=(400,300)); savefig(\"tutorial-plot3.png\"); nothing # hide","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"(Image: Graphique #2)","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"La description complète des attributs des graphiques est disponible à ce lien: http://docs.juliaplots.org/latest/attributes/.","category":"page"},{"location":"julia_vs_matlab/#Quelques-fonctions-usuelles-1","page":"Julia vs MatLab","title":"Quelques fonctions usuelles","text":"","category":"section"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Le tableau suivant se veut un recensement non-exhaustif de certaines commandes usuelles sur MatLab et Julia.","category":"page"},{"location":"julia_vs_matlab/#","page":"Julia vs MatLab","title":"Julia vs MatLab","text":"Opération MatLab Julia Librairie requise\nVecteur linéairement espacé linspace LinRange \nValeur maximale d'un array max maximum \nValeur minimale d'un array min minimum \nRésolution système linéaire \\ \\ LinearAlgebra\nNorme d'un vecteur norm norm LinearAlgebra\nNorm d'une matrice norm opnorm LinearAlgebra\nAffichage sur la console fprintf @printf Printf\nMoyenne d'un array mean mean Statistics\nAffichage d'un graphique plot plot Plots","category":"page"}]
}
