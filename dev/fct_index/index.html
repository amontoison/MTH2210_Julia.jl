<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index des fonctions · MTH2210.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MTH2210.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">MTH2210.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Accueil</a></li><li><a class="tocitem" href="../mise_en_place/">Mise en place</a></li><li><a class="tocitem" href="../julia_vs_matlab/">Julia vs MatLab</a></li><li><a class="tocitem" href="../generate_pdf/">Génération d&#39;un rapport</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../prob_non_lin/">Problèmes non-linéaires</a></li><li><a class="tocitem" href="../edo/">Équations différentielles ordinaires</a></li><li class="is-active"><a class="tocitem" href>Index des fonctions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index des fonctions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index des fonctions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/amontoison/MTH2210.jl/blob/master/docs/src/fct_index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Index-des-fonctions-1"><a class="docs-heading-anchor" href="#Index-des-fonctions-1">Index des fonctions</a><a class="docs-heading-anchor-permalink" href="#Index-des-fonctions-1" title="Permalink"></a></h1><p>Documentation de toute les fonctions du package MTH2210</p><ul><li><a href="#MTH2210.bissec-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.bissec</code></a></li><li><a href="#MTH2210.divided_difference-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>MTH2210.divided_difference</code></a></li><li><a href="#MTH2210.euler-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.euler</code></a></li><li><a href="#MTH2210.eulermod-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.eulermod</code></a></li><li><a href="#MTH2210.lagrange-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MTH2210.lagrange</code></a></li><li><a href="#MTH2210.newton1D-Union{Tuple{T}, Tuple{Function, Function, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.newton1D</code></a></li><li><a href="#MTH2210.newtonND-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.newtonND</code></a></li><li><a href="#MTH2210.newtonNDder-Union{Tuple{T}, Tuple{Function, Function, AbstractVector{T}, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.newtonNDder</code></a></li><li><a href="#MTH2210.ptfixes-Union{Tuple{T}, Tuple{Function, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.ptfixes</code></a></li><li><a href="#MTH2210.ptmilieu-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.ptmilieu</code></a></li><li><a href="#MTH2210.rk4-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.rk4</code></a></li><li><a href="#MTH2210.secante-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.secante</code></a></li><li><a href="#MTH2210.splinec-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>MTH2210.splinec</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MTH2210.bissec-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T&lt;:AbstractFloat" href="#MTH2210.bissec-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.bissec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;une équation non-linéaire de forme <span>$f(r)=0$</span> avec la méthode de la bissection.</p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(approx , err_abs) = bissec(fct , x0 , x1 , nb_it_max , tol_rel)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct         -   Fonction f
2.  x0          -   (Float) Première approximation initiale
3.  x1          -   (Float) Deuxième approximation initiale
4.  nb_it_max   -   (Integer) Nombre maximum d&#39;itérations
5.  tol_rel     -   (Float) Tolérance sur l&#39;approximation de l&#39;erreur relative</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les itérations
2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_fct_nl(x)
    f = x^2 - 10
    return f
end
(approx , err_abs) = bissec(my_fct_nl , 3 , 3.5 , 200 , 1e-9)</code></pre><pre><code class="language-julia">(approx , err_abs) = bissec((x) -&gt; x^2 - 10 , 3 , 3.5 , 200 , 1e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/bissec.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.divided_difference-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#MTH2210.divided_difference-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>MTH2210.divided_difference</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calcul de la table des différences divisées</p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">table_df = divided_difference(xi , yi )</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  xi         	-   (Array{Float,1}) Abscisses des points d&#39;interpolation
2.  yi        	-   (Array{Float,1}) Ordonnées des points d&#39;interpolation</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  table_df 	-   (Array{Float,2}) Table des différences divisées: la 1ère
                    colonne contient les premières différences divisées, la
                    2ème colonne (jusqu&#39;à la ligne end-1) contient les deuxièmes
                    différences divisées,...</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">xi = [2 , 0 , 5 , 3]
yi = [1 , -1 , 10 , -4]

table = divided_difference(xi,yi)
diff_div1 = table[:,1]
diff_div2 = table[1:end-1,2]
diff_div3 = table[1:end-2,3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/splinec.jl#L126-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.euler-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat" href="#MTH2210.euler-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.euler</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;EDOs de type <span>$\frac{dY}{dt}(t) = F(t,Y(t))$</span> avec les conditions initiales <span>$Y(t_0) = Y_0$</span> à l&#39;aide de la méthode d&#39;Euler explicite jusqu&#39;au temps <span>$t_f$</span> avec pas constant <span>$h$</span>:</p><p><span>$Y_{n+1} = Y_{n} + h F(t_n,Y_n)$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(t,Y) = euler(fct , tspan , Y0 , nbpas)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct     -   Fonction décrivant le système de N EDOs
2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])
3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales
4.  nbpas   -   (Integer) Nombre de pas de temps</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps
2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_edo(t,z)
    f = zeros(length(z))
    f[1] = z[2]
    f[2] = -z[1]
    return f
end
(t,y)   =   euler(my_edo , [0;10] , [1;0] , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   euler((t,y) -&gt; cos(t) , [0;2] , 1 , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   euler((t,y) -&gt; [y[2];-y[1]] , [0;10] , [1;0] , 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/euler.jl#L1-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.eulermod-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat" href="#MTH2210.eulermod-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.eulermod</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;EDOs de type <span>$\frac{dY}{dt}(t) = F(t,Y(t))$</span> avec les conditions initiales <span>$Y(t_0) = Y_0$</span> à l&#39;aide de la méthode d&#39;Euler modifié jusqu&#39;au temps <span>$t_f$</span> avec pas constant <span>$h$</span>:</p><p><span>$\tilde{Y} = Y_{n} + h F(t_n,Y_n) \\ Y_{n+1} = Y_n + \frac{h}{2} \left(F(t_n,Y_n) + F(t_n +h, \tilde{Y}) \right)$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(t,Y) = eulermod(fct , tspan , Y0 , nbpas)F(t_n,Y_n) +</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct     -   Fonction décrivant le système de N EDOs
2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])
3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales
4.  nbpas   -   (Integer) Nombre de pas de temps</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps
2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_edo(t,z)
    f = zeros(length(z))
    f[1] = z[2]
    f[2] = -z[1]
    return f
end
(t,y)   =   eulermod(my_edo , [0;10] , [1;0] , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   eulermod((t,y) -&gt; cos(t) , [0;2] , [1] , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   eulermod((t,y) -&gt; [y[2];-y[1]] , [0;10] , [1;0] , 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/eulermod.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.lagrange-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat" href="#MTH2210.lagrange-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MTH2210.lagrange</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolation de Lagrange</p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">Lx = lagrange(xi , yi , x)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  xi          -   (Array{Float,1}) Abscisses des points d&#39;interpolation
2.  yi          -   (Array{Float,1}) Ordonnées des points d&#39;interpolation
3.  x           -   (Array{Float,1}) Points où le polynôme d&#39;interpolation est évalué</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  Lx          -   (Array{Float,1}) Valeur du polynôme aux points x</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">Lx = lagrange([-1,0,1] , [1,0,1] , LinRange(-1,1,200))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/lagrange.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.newton1D-Union{Tuple{T}, Tuple{Function, Function, T, Integer, T}} where T&lt;:AbstractFloat" href="#MTH2210.newton1D-Union{Tuple{T}, Tuple{Function, Function, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.newton1D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;une équation non-linéaire de forme <span>$f(r)=0$</span> avec la méthode de Newton:</p><p><span>$x_{n+1} = x_n - \frac{f(x_n)}{f&#39;(x_n)}$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(approx , err_abs) = newton1D(fct , dfct , x0 , nb_it_max , tol_rel)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct         -   Fonction f
2.  dfct        -   Dérivée de la fonction f
3.  x0          -   (Float) Approximation initiale
4.  nb_it_max   -   (Integer) Nombre maximum d&#39;itérations
5.  tol_rel     -   (Float) Tolérance sur l&#39;approximation de l&#39;erreur relative</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les itérations
2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_fct_nl(x)
    f = x^2 - 10
    return f
end
function my_dfct_nl(x)
    df = 2*x
    return df
end
(approx , err_abs) = newton1D(my_fct_nl , my_dfct_nl , 3 , 20 , 1e-9)</code></pre><pre><code class="language-julia">(approx , err_abs) = newton1D((x) -&gt; x^2 - 10 , (x) -&gt; 2*x , 3 , 20 , 1e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/newton1D.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.newtonND-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Integer, T}} where T&lt;:AbstractFloat" href="#MTH2210.newtonND-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.newtonND</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution dun système non-linéaire de forme <span>$F(r)=0$</span> avec la méthode de Newton en approximant la matrice jacobienne:</p><p><span>$\Delta x = \tilde{J}_F^{-1}(x_n) F(x_n) \\ x_{n+1} = x_n + \Delta x$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(approx , err_abs) = newtonND(fct , x0 , nb_it_max , tol_rel)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct         -   Fonction F
2.  x0          -   (Array{Float,1}) Vecteur des approximations initiales
3.  nb_it_max   -   (Integer) Nombre maximum d&#39;itérations
4.  tol_rel     -   (Float) Tolérance sur l&#39;approximation de l&#39;erreur relative</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  approx      -   (Array{Float,2}) Matrice de taille (nb_iter x N) contenant les itérations
2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_sys_nl(x)
	F = zeros(eltype(x),length(x))
	F[1] = x[1]^2 + x[2]^2 - 1
	F[2] = -x[1]^4 + x[2]
	return F
end
(approx , err_abs) = newtonND(my_sys_nl , [1,1] , 20 , 1e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/newtonND.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.newtonNDder-Union{Tuple{T}, Tuple{Function, Function, AbstractVector{T}, Integer, T}} where T&lt;:AbstractFloat" href="#MTH2210.newtonNDder-Union{Tuple{T}, Tuple{Function, Function, AbstractVector{T}, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.newtonNDder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution dun système non-linéaire de forme <span>$F(r)=0$</span> avec la méthode de Newton:</p><p><span>$\Delta x = J_F^{-1}(x_n) F(x_n) \\ x_{n+1} = x_n + \Delta x$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(approx , err_abs) = newtonNDder(fct , jac , x0 , nb_it_max , tol_rel)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct         -   Fonction F
2.  dfct        -   Matrice jacobienne de la fonction F
3.  x0          -   (Array{Float,1}) Vecteur des approximations initiales
4.  nb_it_max   -   (Integer) Nombre maximum d&#39;itérations
5.  tol_rel     -   (Float) Tolérance sur l&#39;approximation de l&#39;erreur relative</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  approx      -   (Array{Float,2}) Matrice de taille (nb_iter x N) contenant les itérations
2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_sys_nl(x)
	F = zeros(eltype(x),length(x))
	F[1] = x[1]^2 + x[2]^2 - 1
	F[2] = -x[1]^2 + x[2]
	return F
end
function my_sys_nl_jac(x)
	jac = zeros(eltype(x),length(x),length(x))
	jac[1,1] = 2*x[1]
	jac[1,2] = 2*x[2]
	jac[2,1] = -2*x[1]
	jac[2,2] = 1
	return jac
end
(approx , err_abs) = newtonNDder(my_sys_nl , my_sys_nl_jac , [1,1] , 20 , 1e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/newtonNDder.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.ptfixes-Union{Tuple{T}, Tuple{Function, T, Integer, T}} where T&lt;:AbstractFloat" href="#MTH2210.ptfixes-Union{Tuple{T}, Tuple{Function, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.ptfixes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;une équation non-linéaire de forme <span>$g(x)=x$</span> avec la méthode des points-fixes:</p><p><span>$x_{n+1} = g(x_n)$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(approx , err_abs) = ptfixes(fct , x0 , nb_it_max , tol_rel)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct         -   Fonction g
2.  x0          -   (Float) Approximation initiale
4.  nb_it_max   -   (Integer) Nombre maximum d&#39;itérations
5.  tol_rel     -   (Float) Tolérance sur l&#39;approximation de l&#39;erreur relative</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les itérations
2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_fct_nl(x)
    g = -x^2/10 + x + 1
    return g
end
(approx , err_abs) = ptfixes(my_fct_nl , 3 , 25 , 1e-9)</code></pre><pre><code class="language-julia">(approx , err_abs) = ptfixes( (x) -&gt; -x^2/10 + x + 1 , 3 , 25 , 1e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/ptfixes.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.ptmilieu-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat" href="#MTH2210.ptmilieu-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.ptmilieu</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;EDOs de type <span>$\frac{dY}{dt}(t) = F(t,Y(t))$</span> avec les conditions initiales <span>$Y(t_0) = Y_0$</span> à l&#39;aide de la méthode du point milieu jusqu&#39;au temps <span>$t_f$</span> avec pas constant <span>$h$</span>:</p><p><span>$k_1 = h F(t_n,Y_n) \\ Y_{n+1} = Y_n + hF(t_n + \frac{h}{2}, Y_n + \frac{k_1}{2})$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(t,Y) = ptmilieu(fct , tspan , Y0 , nbpas)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct     -   Fonction décrivant le système de N EDOs
2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])
3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales
4.  nbpas   -   (Integer) Nombre de pas de temps</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps
2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_edo(t,z)
    f = zeros(length(z))
    f[1] = z[2]
    f[2] = -z[1]
    return f
end
(t,y)   =   ptmilieu(my_edo , [0;10] , [1;0] , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   ptmilieu((t,y) -&gt; cos(t) , [0;2] , 1 , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   ptmilieu((t,y) -&gt; [y[2];-y[1]] , [0;10] , [1;0] , 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/ptmilieu.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.rk4-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat" href="#MTH2210.rk4-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>MTH2210.rk4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;EDOs de type <span>$\frac{dY}{dt}(t) = F(t,Y(t))$</span> avec les conditions initiales <span>$Y(t_0) = Y_0$</span> à l&#39;aide de la méthode de Runge-Kutta d&#39;ordre 4 jusqu&#39;au temps <span>$t_f$</span> avec pas constant <span>$h$</span>:</p><p><span>$k_1 = h F(t_n,Y_n) \\ k_2 = h F(t_n + \frac{h}{2}, Y_n + \frac{k_1}{2}) \\ k_3 = h F(t_n + \frac{h}{2}, Y_n + \frac{k_2}{2}) \\ k_4 = h F(t_n + h, Y_n + k_3) \\ Y_{n+1} = Y_n + \frac{1}{6} \left(k_1 + 2k_2 +2k_3 +k_4\right)$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(t,Y) = rk4(fct , tspan , Y0 , nbpas)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct     -   Fonction décrivant le système de N EDOs
2.  tspan   -   (Array{Float,1}) Vecteur contenant le temps initial et final (tspan=[t0,tf])
3.  Y0      -   (Array{Float,1}) Vecteur contenant les N conditions initiales
4.  nbpas   -   (Integer) Nombre de pas de temps</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  temps   -   (Array{Float,1}) Vecteur contenant les pas de temps
2.  Y       -   (Array{Float,2}) Matrice de dimension (nbpas+1) x N contenant les approximations</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_edo(t,z)
    f = zeros(length(z))
    f[1] = z[2]
    f[2] = -z[1]
    return f
end
(t,y)   =   rk4(my_edo , [0;10] , [1;0] , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   rk4((t,y) -&gt; cos(t) , [0;2] , 1 , 1000)</code></pre><pre><code class="language-julia">(t,y)   =   rk4((t,y) -&gt; [y[2];-y[1]] , [0;10] , [1;0] , 1000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/rk4.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.secante-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T&lt;:AbstractFloat" href="#MTH2210.secante-Union{Tuple{T}, Tuple{Function, T, T, Integer, T}} where T&lt;:AbstractFloat"><code>MTH2210.secante</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Résolution d&#39;une équation non-linéaire de forme <span>$f(x)=0$</span> avec la méthode de la sécante:</p><p><span>$x_{n+1} = x_n - \frac{f(x_n)\left(x_{n}-x_{n-1}\right)}{f(x_n)-f(x_{n-1})}$</span></p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">(approx , err_abs) = secante(fct , x0 , x1 , nb_it_max , tol_rel)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  fct         -   Fonction f
2.  x0          -   (Float) Première approximation initiale
2.  x1          -   (Float) Deuxième approximation initiale
4.  nb_it_max   -   (Integer) Nombre maximum d&#39;itérations
5.  tol_rel     -   (Float) Tolérance sur l&#39;approximation de l&#39;erreur relative</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  approx      -   (Array{Float,1}) Vecteur de taille nb_iter contenant les	itérations
2.  err_abs     -   (Array{Float,1}) Vecteur de dimension nb_iter contenant les erreurs absolues</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">function my_fct_nl(x)
    f = x^2 - 10
    return f
end
(approx , err_abs) = secante(my_fct_nl , 3 , 3.5 , 20 , 1e-9)</code></pre><pre><code class="language-julia">(approx , err_abs) = secante((x) -&gt; x^2 - 10 , 3 , 3.5 , 20 , 1e-9)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/secante.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MTH2210.splinec-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}" href="#MTH2210.splinec-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}}"><code>MTH2210.splinec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Interpolation par les splines cubiques</p><p><strong>Syntaxe</strong></p><pre><code class="language-julia">Sx = splinec(xi , yi , x , type_f , val_f)</code></pre><p><strong>Entrée</strong></p><pre><code class="language-none">1.  xi          -   (Array{Float,1}) Abscisses des points d&#39;interpolation
2.  yi          -   (Array{Float,1}) Ordonnées des points d&#39;interpolation
3.  x           -   (Array{Float,1}) Points où la spline cubique est évaluée
4.  type_f      -   (Array{Integer,1}) Vecteur des types de conditions frontières
                    imposées en x_0 et x_n. Les choix possibles sont:
                        [1,1] -&gt; Spline naturelle
                        [2,2] -&gt; Spline avec courbure prescrite
                        [3,3] -&gt; Spline avec courbure constane
                        [4,4] -&gt; Spline avec pente prescrite
                        [i,j] -&gt; Spline avec condition i imposée en x0 et
                                 condition j imposée en xn

5.  val_f       -   (Array{Float,1}) Vecteur des valeurs des conditions frontières
                    imposées en x_0 et x_n. Les choix possibles sont:
                        - Si type_S[1] = 1 ou 3, alors val_S[1] = NaN
                        - Si type_S[1] = 2 ou 4, alors val_S[1] = a, où a
                          représente resp. la courbure ou la pente en x0
                        - Si type_S[2] = 1 ou 3, alors val_S[2] = NaN
                        - Si type_S[2] = 2 ou 4, alors val_S[2] = b, où b
                          représente resp. la courbure ou la pente en xn</code></pre><p><strong>Sortie</strong></p><pre><code class="language-none">1.  Sx          -   (Array{Float,1}) Valeur de la spline cubique aux points x</code></pre><p><strong>Exemples d&#39;appel</strong></p><pre><code class="language-julia">Sx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [1,1] , [NaN,NaN])
Sx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [2,2] , [5,-6])
Sx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [3,3] , [NaN,NaN])
Sx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [4,4] , [-30,-10])
Sx = splinec([1,2,4,5] , [1,9,2,11] , LinRange(1,5,200) , [3,4] , [NaN,-10])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/amontoison/MTH2210.jl/blob/ee87ae3bb4f3ee9dc42a9eeb26b68f9bf2ac5e13/src/splinec.jl#L1-L42">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../edo/">« Équations différentielles ordinaires</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 3 February 2022 17:08">Thursday 3 February 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
